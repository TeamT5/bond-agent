# *----- Http Status Code String -----*
HTTP_STATUS_CODE_DICT = {
    100: {
        "code_name": "Continue",
        "message": """
        伺服器已經接收到請求頭，並且客戶端應繼續傳送請求主體（在需要傳送身體的請求的情況下：例如， POST 請求），或者如果請求已經完成，忽略這個回應。伺服器必須在請求完成後向客戶端傳送一個最終回應。
        要使伺服器檢查請求的頭部，客戶端必須在其初始請求中傳送Expect: 100-continue 作為頭部，並在傳送正文之前接收 100 Continue 狀態代碼。回應代碼 417 期望失敗表示請求不應繼續。
        """,
    },
    200: {
        "code_name": "OK",
        "message": """
        請求已成功，請求所希望的回應頭或資料體將隨此回應返回。實際的回應將取決於所使用的請求方法。
        在 GET 請求中，回應將包含與請求的資源相對應的實體。在 POST 請求中，回應將包含描述或操作結果的實體。
        """,
    },
    204: {
        "code_name": "No Content",
        "message": """
        伺服器成功處理了請求，沒有返回任何內容。
        在強制門戶功能中，Wi-Fi 裝置連接到需要進行 Web 認證的 Wi-Fi 存取點時，通過存取一個能生成 HTTP 204 回應的的網站，如果能正常收到 204 回應，則代表無需 Web 認證，
        否則會彈出網頁瀏覽器介面，顯示出 Web 網頁認證介面用於讓使用者認證登入。
        """,
    },
    300: {
        "code_name": "Multiple Choices",
        "message": """
        被請求的資源有一系列可供選擇的回饋資訊，每個都有自己特定的位址和瀏覽器驅動的商議資訊。使用者或瀏覽器能夠自行選擇一個首選的位址進行重新導向。
        除非這是一個 HEAD 請求，否則該回應應當包括一個資源特性及位址的列表的實體，以便使用者或瀏覽器從中選擇最合適的重新導向位址。這個實體的格式由 Content-Type 定義的格式所決定。瀏覽器可能根據回應的格式以及瀏覽器自身能力，自動作出最合適的選擇。當然，RFC 2616 規範並沒有規定這樣的自動選擇該如何進行。
        如果伺服器本身已經有了首選的回饋選擇，那麼在 Location 中應當指明這個回饋的 URI；瀏覽器可能會將這個 Location 值作為自動重新導向的位址。此外，除非額外指定，否則這個回應也是可快取的。
        """,
    },
    301: {
        "code_name": "Moved Permanently",
        "message": """
        被請求的資源已永久移動到新位置，並且將來任何對此資源的參照都應該使用本回應返回的若干個 URI 之一。如果可能，擁有連結編輯功能的客戶端應當自動把請求的位址修改為從伺服器回饋回來的位址。
        除非額外指定，否則這個回應也是可快取的。
        新的永久性的URI應當在回應的 Location 域中返回。除非這是一個HEAD請求，否則回應的實體中應當包含指向新的URI的超連結及簡短說明。
        如果這不是一個 GET 或者 HEAD 請求，那麼瀏覽器禁止自動進行重新導向，除非得到使用者的確認，因為請求的條件可能因此發生變化。
        注意：對於某些使用 HTTP/1.0 協定的瀏覽器，當它們傳送的 POST 請求得到了一個 301 回應的話，接下來的重新導向請求將會變成 GET 方式。
        """,
    },
    304: {
        "code_name": "Not Modified",
        "message": """
        表示資源在由請求頭中的 If-Modified-Since 或 If-None-Match 參數指定的這一版本之後，未曾被修改。在這種情況下，由於客戶端仍然具有以前下載的副本，因此不需要重新傳輸資源。
        """,
    },
    305: {
        "code_name": "Use Proxy",
        "message": """
        被請求的資源必須通過指定的代理才能被存取。Location 域中將給出指定的代理所在的 URI 資訊，接收者需要重複傳送一個單獨的請求，通過這個代理才能存取相應資源。
        只有原始伺服器才能建立 305 回應。
        許多 HTTP 客戶端（像是 Mozilla）都沒有正確處理這種狀態代碼的回應，主要是出於安全考慮。
        注意： RFC 2068 中沒有明確 305 回應是為了重新導向一個單獨的請求，而且只能被原始伺服器建立。忽視這些限制可能導致嚴重的安全後果。
        """,
    },
    400: {
        "code_name": "Bad Request",
        "message": """
        由於明顯的客戶端錯誤（例如，格式錯誤的請求語法，太大的大小，無效的請求訊息或欺騙性路由請求），伺服器不能或不會處理該請求。
        """,
    },
    401: {
        "code_name": "Unauthorized",
        "message": """
        類似於 403 Forbidden，401 語意即「未認證」，即使用者沒有必要的憑據。
        該狀態碼表示當前請求需要使用者驗證。
        該回應必須包含一個適用於被請求資源的 WWW-Authenticate 資訊頭用以詢問使用者資訊。
        客戶端可以重複提交一個包含恰當的 Authorization 頭資訊的請求。
        如果當前請求已經包含了 Authorization 憑證，那麼 401 回應代表著伺服器驗證已經拒絕了那些憑證。
        如果 401 回應包含了與前一個回應相同的身分驗證詢問，且瀏覽器已經至少嘗試了一次驗證，那麼瀏覽器應當向使用者展示回應中包含的實體資訊，因為這個實體資訊中可能包含了相關診斷資訊。
        注意：當網站（通常是網站域名）禁止 IP 位址時，有些網站狀態碼顯示的 401，表示該特定位址被拒絕存取網站。
        """,
    },
    403: {
        "code_name": "Forbidden",
        "message": """
        伺服器已經理解請求，但是拒絕執行它。
        與 401 回應不同的是，身分驗證並不能提供任何幫助，而且這個請求也不應該被重複提交。
        如果這不是一個 HEAD 請求，而且伺服器希望能夠講清楚為何請求不能被執行，那麼就應該在實體內描述拒絕的原因。
        當然伺服器也可以返回一個 404 回應，假如它不希望讓客戶端獲得任何資訊。
        """,
    },
    404: {
        "code_name": "Not Found",
        "message": """
        請求失敗，請求所希望得到的資源未被在伺服器上發現，但允許使用者的後續請求。
        沒有資訊能夠告訴使用者這個狀況到底是暫時的還是永久的。
        假如伺服器知道情況的話，應當使用 410 狀態碼來告知舊資源因為某些內部的組態機制問題，已經永久的不可用，而且沒有任何可以跳轉的位址。
        404 這個狀態碼被廣泛應用於當伺服器不想揭示到底為何請求被拒絕或者沒有其他適合的回應可用的情況下。
        """,
    },
    405: {
        "code_name": "Method Not Allowed",
        "message": """
        請求行中指定的請求方法不能被用於請求相應的資源。該回應必須返回一個 Allow 頭資訊用以表示出當前資源能夠接受的請求方法的列表。
        例如，需要通過 POST 呈現資料的表單上的 GET 請求，或唯讀資源上的 PUT 請求。
        鑑於 PUT，DELETE 方法會對伺服器上的資源進行寫操作，因而絕大部分的網頁伺服器都不支援或者在預設組態下不允許上述請求方法，對於此類請求均會返回 405 錯誤。
        """,
    },
    406: {
        "code_name": "Not Acceptable",
        "message": """
        請求的資源的內容特性無法滿足請求頭中的條件，因而無法生成回應實體，該請求不可接受。
        除非這是一個 HEAD 請求，否則該回應就應當返回一個包含可以讓使用者或者瀏覽器從中選擇最合適的實體特性以及網址列表的實體。
        實體的格式由 Content-Type 頭中定義的媒體類型決定。
        瀏覽器可以根據格式及自身能力自行作出最佳選擇。但是，規範中並沒有定義任何作出此類自動選擇的標準。
        """,
    },
    407: {
        "code_name": "Proxy Authentication Required",
        "message": """
        與 401 回應類似，只不過客戶端必須在代理伺服器上進行身分驗證。
        代理伺服器必須返回一個 Proxy-Authenticate 用以進行身分詢問。
        客戶端可以返回一個 Proxy-Authorization 資訊頭用以驗證。
        """,
    },
    408: {
        "code_name": "Request Timeout",
        "message": """
        請求逾時。根據 HTTP 規範，客戶端沒有在伺服器預備等待的時間內完成一個請求的傳送，客戶端可以隨時再次提交這一請求而無需進行任何更改。
        """,
    },
    409: {
        "code_name": "Conflict",
        "message": """
        表示因為請求存在衝突無法處理該請求，例如多個同步更新之間的編輯衝突。
        """,
    },
    410: {
        "code_name": "Gone",
        "message": """
        表示所請求的資源不再可用。
        當資源被有意地刪除並且資源應被清除時，應該使用這個。
        在收到 410 狀態碼後，使用者應停止再次請求資源。
        但大多數伺服器端不會使用此狀態碼，而是直接使用 404 狀態碼。
        """,
    },
    412: {
        "code_name": "Precondition Failed",
        "message": """
        伺服器在驗證在請求的頭欄位中給出先決條件時，沒能滿足其中的一個或多個。
        這個狀態碼允許客戶端在取得資源時在請求的元資訊（請求頭欄位資料）中設定先決條件，以此避免該請求方法被應用到其希望的內容以外的資源上。
        """,
    },
    422: {
        "code_name": "Unprocessable Entity",
        "message": """
        請求格式正確，但是由於含有語意錯誤，無法回應。
        """,
    },
    423: {
        "code_name": "Locked",
        "message": """
        當前資源被鎖定。
        """,
    },
    426: {
        "code_name": "Upgrade Required",
        "message": """
        客戶端應切換到 Upgrade 頭欄位中給出的不同協定，如 TLS/1.0。
        """,
    },
    500: {
        "code_name": "Internal Server Error",
        "message": """
        通用錯誤訊息，伺服器遇到了一個未曾預料的狀況，導致了它無法完成對請求的處理。沒有給出具體錯誤資訊。
        """,
    },
    501: {
        "code_name": "Not Implemented",
        "message": """
        伺服器不支援當前請求所需要的某個功能。當伺服器無法辨識請求的方法，並且無法支援其對任何資源的請求。
        例如，網路服務API的新功能
        """,
    },
    502: {
        "code_name": "Bad Gateway",
        "message": """
        作為閘道器或者代理工作的伺服器嘗試執行請求時，從上游伺服器接收到無效的回應。
        """,
    },
    503: {
        "code_name": "Service Unavailable",
        "message": """
        由於臨時的伺服器維護或者過載，伺服器當前無法處理請求。
        這個狀況是暫時的，並且將在一段時間以後恢復。
        如果能夠預計延遲時間，那麼回應中可以包含一個 Retry-After 頭用以標明這個延遲時間。
        如果沒有給出這個 Retry-After 資訊，那麼客戶端應當以處理 500 回應的方式處理它。
        """,
    },
    504: {
        "code_name": "Gateway Timeout",
        "message": """
        作為閘道器或者代理工作的伺服器嘗試執行請求時，未能及時從上游伺服器（URI 標識出的伺服器，例如 HTTP、FTP、LDAP）或者輔助伺服器（例如 DNS）收到回應。
        注意：某些代理伺服器在 DNS 查詢逾時時會返回 400 或者 500 錯誤。
        """,
    },
    505: {
        "code_name": "HTTP Version Not Supported",
        "message": """
        伺服器不支援，或者拒絕支援在請求中使用的 HTTP 版本。
        這暗示著伺服器不能或不願使用與客戶端相同的版本。
        回應中應當包含一個描述了為何版本不被支援以及伺服器支援哪些協定的實體。
        """,
    },
    506: {
        "code_name": "Variant Also Negotiates",
        "message": """
        由《透明內容協商協定》（RFC 2295）擴充，代表伺服器存在內部組態錯誤，被請求的協商變元資源被組態為在透明內容協商中使用自己，因此在一個協商處理中不是一個合適的重點。
        """,
    },
    507: {
        "code_name": "Insufficient Storage",
        "message": """
        伺服器無法儲存完成請求所必須的內容。這個狀況被認為是臨時的。
        """,
    },
    508: {
        "code_name": "Loop Detected",
        "message": """
        伺服器在處理請求時陷入無窮迴圈。
        """,
    },
    510: {
        "code_name": "Not Extended",
        "message": """
        取得資源所需要的策略並沒有被滿足。
        """,
    },
    511: {
        "code_name": "Network Authentication Required",
        "message": """
        客戶端需要進行身分驗證才能獲得網路存取權限，旨在限制使用者群存取特定網路。
        （例如連接 WiFi 熱點時的強制網路門戶）
        """,
    },
}
